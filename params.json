{"tagline":"Application namespacing and module management.","google":"UA-33799005-1","body":"# Applitude - Simple module management.\r\n\r\nApplitude is a simple event-driven client-side JavaScript application architecture and module management framework that serves the following needs:\r\n\r\n* Namespacing\r\n* Sandbox\r\n* Environment\r\n* Loading performance boost\r\n* Mixins\r\n* Deferred utilities\r\n\r\nView the slideshow: [\"Introducing Applitude: Simple Module Management\"](https://docs.google.com/presentation/embed?id=1BQ6s5EzLqenWZX1RCUIgVlJViKzjZAvvxN4UVkQzspo&start=false&loop=false&delayms=10000)\r\n\r\n**Status** - Developer preview (stick to tested, documented features for best results). In production use with millions of monthly active users.\r\nThere are [unit tests](http://applitude.herokuapp.com/) covering most of the functionality. [![Build Status](https://secure.travis-ci.org/dilvie/applitude.png)](http://travis-ci.org/dilvie/applitude)\r\n\r\nThe guiding philosophy of Applitude is “Less is more.” Applitude sets up the sandbox and then gets out of the way of your modules. Hence the subtitle, “Simple Module Management.”\r\n\r\n\r\n## A Simple Applitude Module\r\n\r\n*Tip:* Wrap your module with an Immediately Invoked Anonymous Expression (IIFE), and pass applitude into it to create a handy 'app' shortcut in your code:\r\n\r\n    (function (app) {\r\n      'use strict';\r\n    \r\n      /**\r\n       * uniqueId\r\n       * returns a short random string, prepended with epoch time\r\n       * converted into a short sequence of characters.\r\n       * \r\n       * @return [String] \r\n       */\r\n      app.register('uniqueId', function uniqueId() {\r\n        return (new Date().getTime() << 0).toString(36)\r\n            + (\"0000\" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).substr(-4);\r\n      });\r\n    \r\n    }(applitude));\r\n\r\n## Create an app\r\n\r\n    app(namespace, environmentObject, optionsObject);\r\n\r\n### Environment\r\n\r\nEnvironment is made up of things like image hosting URLs which might vary from one host or CDN to another. Generally server side environments will also contain passwords, secrets, or tokens for communicating with third party APIs. Since the client-side JavaScript environment is not secure, you should not pass those secrets through to the JavaScript layer.\r\n\r\nEnvironment variables should be passed into your application from your environment configuration, and not hard-coded. Your application should be portable to new hardware or hosts without any changes to your codebase.\r\n\r\nIt might be tempting to pass a single environment string through and put logic in your code to determine URLs and so on, but that should be done at the configuration level wherever possible. That will make it easier to port your app to new environments.\r\n\r\nAs a general rule of thumb, your app should be ready to open-source at any time, even if you never intend to do it. That mode of thought will help establish the proper separation of environment configuration and secrets from application code.\r\n\r\nApplitude expects at least one varible to be defined: `debug` (Bool) If `debug` is true, anything logged with `app.log()` will be printed to the console (if available).\r\n\r\nFor more on application configuration, see [\"The Twelve-Factor App\"](http://www.12factor.net/config)\r\n\r\n### Options\r\n\r\nIt will also look for a beforeRender array of promises. If passed, no modules will render until all beforeRender promises have resolved.\r\n\r\nAny other options will be made available on the `app.options` object. Here's a sample:\r\n\r\n    (function (app) {\r\n      var namespace = 'applitudeTest',\r\n        whenAppInitFinished = app.deferred();\r\n    \r\n      app(namespace,\r\n        {\r\n          debug: true\r\n        },\r\n        {\r\n          beforeRender: [whenAppInitFinished.promise()],\r\n          optionAdded: true,\r\n          whenAppInitFinished: whenAppInitFinished\r\n        });\r\n    }(applitude));\r\n\r\n## Applitude Responsibilities\r\n\r\n### Events\r\n\r\nModules should know as little as possible about each other. To that end, modules should communicate through a global event bus, supplied by the applitude sandbox. You can use `app.on()` to subscribe to events, and `app.trigger()` to publish.\r\n\r\n    app.on('a.*', function (data) { \r\n        console.log(data);\r\n    });\r\n    \r\n    // later\r\n    app.trigger('a.b', 'hello, world'); // logs 'hello, world'\r\n\r\nBest practice is to get specific about the events you report, and always use your modules namespace to trigger. For example:\r\n\r\n\r\n    (function (app) {\r\n        var namespace = 'videoPlayer',\r\n            api;\r\n    \r\n        function bindEvents() {\r\n            app.$('#' + namespace).on('click', '#playButton', function (event) {\r\n                app.trigger('click.' + namespace, event);\r\n            });\r\n        }\r\n    \r\n        // Wait for the dom to be ready before we try to \r\n        api = {\r\n            render: bindEvents\r\n        };\r\n    \r\n        app.register(namespace, api);\r\n    }(applitude));\r\n    \r\nEvents support wildcards. This way, you can implement cross-cutting concerns. For example, log every click in your app:\r\n\r\n    (function (app) {\r\n        var namespace = 'clickLogger',\r\n            api;\r\n        \r\n        app.on('click.*', function logData(event) {\r\n            // Implement real logging here. This just spits it into the in-memory app log.\r\n            app.log(event);\r\n        });\r\n        \r\n        function recent() {\r\n            // get recent log entries\r\n        }\r\n        \r\n        api = {\r\n            recent: recent\r\n        };\r\n        \r\n        app.register(namespace, api);\r\n    }(applitude));\r\n\r\n* **Namespacing**. Modules can only be registered once, in order to avoid duplicate code runs, and tricky associated bugs.\r\n\r\n        // A module to generate short unique ID strings...\r\n        app.register('uniqueId', function uniqueId() {\r\n          return (new Date().getTime() << 0).toString(36)\r\n              + (\"0000\" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).substr(-4);\r\n        });\r\n\r\n\r\n        // elsewhere...\r\n        test('Applitude namespacing', function () {\r\n          equal(typeof app.uniqueId(), 'string',\r\n            '.register() should work with functions.');\r\n    \r\n          app.register('uniqueId', function () {\r\n            return false;\r\n          });\r\n    \r\n          equal(typeof app.uniqueId(), 'string',\r\n            '.register() should throw an error on duplicate register.');\r\n        });\r\n\r\n* **A sandbox** to access libraries through a canonical interface, rather than calling library code directly. Doing so allows you to modify the implementation, or swap out the library completely with transparency to the application code.\r\n\r\n* **Loading performance boost**. Loading data blocks data rendering, so it makes sense to load data as early as possible using non-blocking means in order to render it as quickly as possible. Applitude decouples data loading from data rendering via .load() and .render() methods. .load() runs as early as possible, and .render() runs only after page ready and beforeRender have both finished.\r\n\r\n* **beforeRender** is a list of promises which all must finish before .render() begins. For example, many apps will need i18n translations to load before any module is allowed to render. By adding an i18n promise to the application's beforeRender queue, you can postpone render until the translations are loaded. Using beforeRender can prevent tricky race condition bugs from cropping up, and provide a neat solution if you need a guaranteed way to handle tasks before the modules render.\r\n\r\n        var whenModuleReady = app.deferred();\r\n  \r\n        app.register('testModuleBeforeRender', {\r\n          beforeRender: [whenModuleReady]\r\n        });\r\n\r\n* **Environment**. A canonical place to store application environment variables -- things like urls for development, staging, or production servers, etc... You can pass an environment object into the app in the initial applitude call.\r\n\r\n* **Mixins**. Each module can declare a list of other modules to mix in with applitude. The new module can selectively override attributes from the mixed-in modules. The mixins later in the list will override attributes picked up from mixins earlier in the list... in other words, for collisions, the last mixin wins.\r\n    \r\n        \r\n        test('Applitude mixins', function () {\r\n          app.register('aMixin', {\r\n            foo: 'foo',\r\n            bar: 'bar'\r\n          });\r\n          app.register('usesMixin', {\r\n            bar: 'baz',\r\n            mixins: 'aMixin'\r\n          });\r\n        \r\n          equal(app.usesMixin.foo, 'foo',\r\n            'Register should pull in module mixins.');\r\n        \r\n          equal(app.usesMixin.bar, 'baz',\r\n            'Modules should be able to override mixins.');\r\n        \r\n          equal(app.aMixin.bar, 'bar',\r\n            'Original mixin should not be modified by override.');\r\n        });\r\n\r\n* **Deferred utilities** - Applitude relies on promises and deferreds from the jQuery library (along with other jQuery goodness, such as the page ready function). Applitude exposes a few Deferred utilities, including `.resolved` (a resolved promise), `.rejected` (a rejected promise), `.when()` (a utility that allows you to run callbacks only after all promises passed to it are resolved), and `.queue()`, like `.when()`, but you can add promises to the wait queue at any time. The promise returned by `.queue()` resolves when all of the promises in the queue are resolved. These utilities can be helpful for coordinating asynchronous events in your application.","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Applitude"}